#include "cl_viv_vx_ext.h"

 typedef struct _complex_fft
 {
     float real;
     float image;
 }complex_fft;

 float2 Add(float2 c1, float2 c2)
{
    float2 c;
    c.x = c1.x+c2.x;
    c.y = c1.y+c2.y;
    return c;
}

float2 Sub(float2 c1, float2 c2)
{
    float2 c;
    c.x = c1.x-c2.x;
    c.y = c1.y-c2.y;
    return c;
}

float2 Mul(float2 c1, float2 c2)
{
    float2 c;
    c.x = c1.x*c2.x-c1.y*c2.y;
    c.y = c1.x*c2.y+c2.x*c1.y;
    return c;
}
__constant float2 weight_array64[] = {
    (float2)(1.0, -0.000),(float2)(0.995184720, -0.0980171412),(float2)(0.980785310, -0.195090324),(float2)(0.956940353, -0.290284663),
    (float2)(0.923879564, -0.382683426),(float2)(0.881921291, -0.471396744),(float2)(0.831469595, -0.555570245),(float2)(0.773010433, -0.634393275),
    (float2)(0.707106769, -0.707106769),(float2)(0.634393275, -0.773010433),(float2)(0.555570245, -0.831469595),(float2)(0.471396744, -0.881921232),
    (float2)(0.382683456, -0.923879504),(float2)(0.290284693, -0.956940353),(float2)(0.195090339, -0.980785251),(float2)(0.0980171636, -0.995184720),
    (float2)(2.67948970e-008, -1.00000000),(float2)(-0.0980171114, -0.995184720),(float2)(-0.195090294, -0.980785310),(float2)(-0.290284634, -0.956940353),
    (float2)(-0.382683396, -0.923879564),(float2)(-0.471396714, -0.881921291),(float2)(-0.555570185, -0.831469655),(float2)(-0.634393275, -0.773010492),
    (float2)(-0.707106769, -0.707106829),(float2)(-0.773010433, -0.634393334),(float2)(-0.831469595, -0.555570245),(float2)(-0.881921232, -0.471396774),
    (float2)(-0.923879504, -0.382683486),(float2)(-0.956940293, -0.290284723),(float2)(-0.980785251, -0.195090368),(float2)(-0.995184720, -0.0980171934)
    };

__constant float2 weight_array256[] = {
    (float2)(1.00000000, -0.000000000), (float2)(0.999698818, -0.0245412290), (float2)(0.998795450, -0.0490676723), (float2)(0.997290432, -0.0735645592),
    (float2)(0.995184720, -0.0980171412), (float2)(0.992479563, -0.122410670), (float2)(0.989176512, -0.146730468), (float2)(0.985277653, -0.170961887),
    (float2)(0.980785310, -0.195090324), (float2)(0.975702107, -0.219101235), (float2)(0.970031261, -0.242980182), (float2)(0.963776052, -0.266712755),
    (float2)(0.956940353, -0.290284663), (float2)(0.949528158, -0.313681722), (float2)(0.941544056, -0.336889833), (float2)(0.932992816, -0.359895021),
    (float2)(0.923879564, -0.382683426), (float2)(0.914209783, -0.405241311), (float2)(0.903989315, -0.427555084), (float2)(0.893224299, -0.449611336),
    (float2)(0.881921291, -0.471396744), (float2)(0.870086968, -0.492898196), (float2)(0.857728601, -0.514102757), (float2)(0.844853580, -0.534997582),
    (float2)(0.831469595, -0.555570245), (float2)(0.817584813, -0.575808167), (float2)(0.803207517, -0.595699310), (float2)(0.788346410, -0.615231574),
    (float2)(0.773010433, -0.634393275), (float2)(0.757208884, -0.653172851), (float2)(0.740951121, -0.671558917), (float2)(0.724247098, -0.689540565),
    (float2)(0.707106769, -0.707106769), (float2)(0.689540565, -0.724247098), (float2)(0.671558976, -0.740951121), (float2)(0.653172851, -0.757208824),
    (float2)(0.634393275, -0.773010433), (float2)(0.615231574, -0.788346410), (float2)(0.595699310, -0.803207517), (float2)(0.575808227, -0.817584813),
    (float2)(0.555570245, -0.831469595), (float2)(0.534997642, -0.844853580), (float2)(0.514102757, -0.857728601), (float2)(0.492898196, -0.870086968),
    (float2)(0.471396744, -0.881921232), (float2)(0.449611336, -0.893224299), (float2)(0.427555114, -0.903989255), (float2)(0.405241340, -0.914209723),
    (float2)(0.382683456, -0.923879504), (float2)(0.359895051, -0.932992816), (float2)(0.336889863, -0.941544056), (float2)(0.313681751, -0.949528158),
    (float2)(0.290284693, -0.956940353), (float2)(0.266712785, -0.963776052), (float2)(0.242980197, -0.970031261), (float2)(0.219101265, -0.975702107),
    (float2)(0.195090339, -0.980785251), (float2)(0.170961916, -0.985277653), (float2)(0.146730497, -0.989176512), (float2)(0.122410700, -0.992479503),
    (float2)(0.0980171636, -0.995184720), (float2)(0.0735645890, -0.997290432), (float2)(0.0490676984, -0.998795450), (float2)(0.0245412551, -0.999698818),
    (float2)(2.67948970e-008, -1.00000000), (float2)(-0.0245412011, -0.999698818), (float2)(-0.0490676463, -0.998795450), (float2)(-0.0735645369, -0.997290432),
    (float2)(-0.0980171114, -0.995184720), (float2)(-0.122410648, -0.992479563), (float2)(-0.146730453, -0.989176512), (float2)(-0.170961857, -0.985277653),
    (float2)(-0.195090294, -0.980785310), (float2)(-0.219101205, -0.975702107), (float2)(-0.242980152, -0.970031261), (float2)(-0.266712725, -0.963776052),
    (float2)(-0.290284634, -0.956940353), (float2)(-0.313681722, -0.949528217), (float2)(-0.336889833, -0.941544056), (float2)(-0.359894991, -0.932992816),
    (float2)(-0.382683396, -0.923879564), (float2)(-0.405241281, -0.914209783), (float2)(-0.427555054, -0.903989315), (float2)(-0.449611306, -0.893224299),
    (float2)(-0.471396714, -0.881921291), (float2)(-0.492898166, -0.870087028), (float2)(-0.514102697, -0.857728601), (float2)(-0.534997582, -0.844853580),
    (float2)(-0.555570185, -0.831469655), (float2)(-0.575808167, -0.817584813), (float2)(-0.595699251, -0.803207576), (float2)(-0.615231574, -0.788346469),
    (float2)(-0.634393275, -0.773010492), (float2)(-0.653172791, -0.757208884), (float2)(-0.671558917, -0.740951180), (float2)(-0.689540505, -0.724247098),
    (float2)(-0.707106769, -0.707106829), (float2)(-0.724247038, -0.689540565), (float2)(-0.740951121, -0.671558976), (float2)(-0.757208824, -0.653172851),
    (float2)(-0.773010433, -0.634393334), (float2)(-0.788346410, -0.615231633), (float2)(-0.803207517, -0.595699310), (float2)(-0.817584813, -0.575808227),
    (float2)(-0.831469595, -0.555570245), (float2)(-0.844853520, -0.534997642), (float2)(-0.857728601, -0.514102757), (float2)(-0.870086968, -0.492898226),
    (float2)(-0.881921232, -0.471396774), (float2)(-0.893224299, -0.449611366), (float2)(-0.903989255, -0.427555144), (float2)(-0.914209723, -0.405241370),
    (float2)(-0.923879504, -0.382683486), (float2)(-0.932992756, -0.359895080), (float2)(-0.941544056, -0.336889893), (float2)(-0.949528158, -0.313681781),
    (float2)(-0.956940293, -0.290284723), (float2)(-0.963776052, -0.266712815), (float2)(-0.970031261, -0.242980227), (float2)(-0.975702107, -0.219101295),
    (float2)(-0.980785251, -0.195090368), (float2)(-0.985277653, -0.170961931), (float2)(-0.989176512, -0.146730527), (float2)(-0.992479503, -0.122410730),
    (float2)(-0.995184720, -0.0980171934), (float2)(-0.997290432, -0.0735646188), (float2)(-0.998795450, -0.0490677282), (float2)(-0.999698818, -0.0245412812)
};

__constant float2 weight_array128[] = {
    (float2)(1.00000000, -0.000000000), (float2)(0.998795450, -0.0490676723), (float2)(0.995184720, -0.0980171412), (float2)(0.989176512, -0.146730468),
    (float2)(0.980785310, -0.195090324), (float2)(0.970031261, -0.242980182), (float2)(0.956940353, -0.290284663), (float2)(0.941544056, -0.336889833),
    (float2)(0.923879564, -0.382683426), (float2)(0.903989315, -0.427555084), (float2)(0.881921291, -0.471396744), (float2)(0.857728601, -0.514102757),
    (float2)(0.831469595, -0.555570245), (float2)(0.803207517, -0.595699310), (float2)(0.773010433, -0.634393275), (float2)(0.740951121, -0.671558917),
    (float2)(0.707106769, -0.707106769), (float2)(0.671558976, -0.740951121), (float2)(0.634393275, -0.773010433), (float2)(0.595699310, -0.803207517),
    (float2)(0.555570245, -0.831469595), (float2)(0.514102757, -0.857728601), (float2)(0.471396744, -0.881921232), (float2)(0.427555114, -0.903989255),
    (float2)(0.382683456, -0.923879504), (float2)(0.336889863, -0.941544056), (float2)(0.290284693, -0.956940353), (float2)(0.242980197, -0.970031261),
    (float2)(0.195090339, -0.980785251), (float2)(0.146730497, -0.989176512), (float2)(0.0980171636, -0.995184720), (float2)(0.0490676984, -0.998795450),
    (float2)(2.67948970e-008, -1.00000000), (float2)(-0.0490676463, -0.998795450), (float2)(-0.0980171114, -0.995184720), (float2)(-0.146730453, -0.989176512),
    (float2)(-0.195090294, -0.980785310), (float2)(-0.242980152, -0.970031261), (float2)(-0.290284634, -0.956940353), (float2)(-0.336889833, -0.941544056),
    (float2)(-0.382683396, -0.923879564), (float2)(-0.427555054, -0.903989315), (float2)(-0.471396714, -0.881921291), (float2)(-0.514102697, -0.857728601),
    (float2)(-0.555570185, -0.831469655), (float2)(-0.595699251, -0.803207576), (float2)(-0.634393275, -0.773010492), (float2)(-0.671558917, -0.740951180),
    (float2)(-0.707106769, -0.707106829), (float2)(-0.740951121, -0.671558976), (float2)(-0.773010433, -0.634393334), (float2)(-0.803207517, -0.595699310),
    (float2)(-0.831469595, -0.555570245), (float2)(-0.857728601, -0.514102757), (float2)(-0.881921232, -0.471396774), (float2)(-0.903989255, -0.427555144),
    (float2)(-0.923879504, -0.382683486), (float2)(-0.941544056, -0.336889893), (float2)(-0.956940293, -0.290284723), (float2)(-0.970031261, -0.242980227),
    (float2)(-0.980785251, -0.195090368), (float2)(-0.989176512, -0.146730527), (float2)(-0.995184720, -0.0980171934), (float2)(-0.998795450, -0.0490677282)
};

__constant short bitpos_64[] = {
0, 32, 16, 48, 8,  40, 24, 56,
4, 36, 20, 52, 12, 44, 28, 60,
2, 34, 18, 50, 10, 42, 26, 58,
6, 38, 22, 54, 14, 46, 30, 62,
1, 33, 17, 49, 9,  41, 25, 57,
5, 37, 21, 53, 13, 45, 29, 61,
3, 35, 19, 51, 11, 43, 27, 59,
7, 39, 23, 55, 15, 47, 31, 63
};

__constant short bitpos_128[] = {
0,  64, 32, 96, 16, 80, 48, 112,
8,  72, 40, 104, 24, 88, 56, 120,
4,  68, 36, 100, 20, 84, 52, 116,
12, 76, 44, 108, 28, 92, 60, 124,
2,  66, 34, 98, 18, 82, 50, 114,
10, 74, 42, 106, 26, 90, 58, 122,
6,  70, 38, 102, 22, 86, 54, 118,
14, 78, 46, 110, 30, 94, 62, 126,
1,  65, 33, 97, 17, 81, 49, 113,
9,  73, 41, 105, 25, 89, 57, 121,
5,  69, 37, 101, 21, 85, 53, 117,
13, 77, 45, 109, 29, 93, 61, 125,
3,  67, 35, 99, 19, 83, 51, 115,
11, 75, 43, 107, 27, 91, 59, 123,
7,  71, 39, 103, 23, 87, 55, 119,
15, 79, 47, 111, 31, 95, 63, 127
};

__constant short bitpos_256[] = {
0,   128, 64, 192, 32, 160, 96, 224,
16,  144, 80, 208, 48, 176, 112, 240,
8,   136, 72, 200, 40, 168, 104, 232,
24,  152, 88, 216, 56, 184, 120, 248,
4,   132, 68, 196, 36, 164, 100, 228,
20,  148, 84, 212, 52, 180, 116, 244,
12,  140, 76, 204, 44, 172, 108, 236,
28,  156, 92, 220, 60, 188, 124, 252,
2,   130, 66, 194, 34, 162, 98, 226,
18,  146, 82, 210, 50, 178, 114, 242,
10,  138, 74, 202, 42, 170, 106, 234,
26,  154, 90, 218, 58, 186, 122, 250,
6,   134, 70, 198, 38, 166, 102, 230,
22,  150, 86, 214, 54, 182, 118, 246,
14,  142, 78, 206, 46, 174, 110, 238,
30,  158, 94, 222, 62, 190, 126, 254,
1,   129, 65, 193, 33, 161, 97, 225,
17,  145, 81, 209, 49, 177, 113, 241,
9,   137, 73, 201, 41, 169, 105, 233,
25,  153, 89, 217, 57, 185, 121, 249,
5,   133, 69, 197, 37, 165, 101, 229,
21,  149, 85, 213, 53, 181, 117, 245,
13,  141, 77, 205, 45, 173, 109, 237,
29,  157, 93, 221, 61, 189, 125, 253,
3,   131, 67, 195, 35, 163, 99, 227,
19,  147, 83, 211, 51, 179, 115, 243,
11,  139, 75, 203, 43, 171, 107, 235,
27,  155, 91, 219, 59, 187, 123, 251,
7,   135, 71, 199, 39, 167, 103, 231,
23,  151, 87, 215, 55, 183, 119, 247,
15,  143, 79, 207, 47, 175, 111, 239,
31,  159, 95, 223, 63, 191, 127, 255
};

__kernel __attribute__((reqd_work_group_size(64, 1, 1))) void fft_64x64(
    vx_array_float input,
    vx_array_float output,
    int nLen, int N, int mLen, int M) //width height
{
    int gidx = get_global_id(0);
    __global float2* A = (__global float2*)input.item;
    //__global float2* tA = (__global float2*)tmpBuf.item;
    __local float2 tmp_array[64 * 64];
    //__local float2* tA = tmp_array;
    int i;

    int b = 0;
    int offset = gidx * 64;
    {
    for(i = 0; i < 64; i++)
    {
        b = bitpos_64[i];
        tmp_array[offset + i] = A[offset + b];
    }
    }

    __local float2* rA = tmp_array + offset;

    int lev, dist, p, t, d, step;
    float2 B;
    i = 0;
#if 1 // fft
    for(lev=1; lev<=N; lev++)
    {
        dist = 1 << (lev-1);
        d = 1 << (N-lev);
        step = 1 << lev;
        for(t = 0; t < dist; t++)
        {
            p = t * d;
            for(i = t; i < nLen; i += step)
            {
                B = Add(rA[i], Mul(rA[i+dist], weight_array64[p]));
                rA[i+dist] = Sub(rA[i], Mul(rA[i+dist], weight_array64[p]));
                rA[i].x = B.x;
                rA[i].y = B.y;
            }
        }
    }
#endif

    for(i = 0; i < 64; i++)
    {
        A[offset + i] = rA[i];
    }
    barrier(CLK_LOCAL_MEM_FENCE);

    // vertical
    for(i = 0; i < 64; i++)
    {
        b = bitpos_64[i] << 6;
        tmp_array[offset + i] = A[b + gidx];
    }
    rA = tmp_array + offset;

#if 1
    i = 0;
    for(lev=1; lev<=M; lev++)
    {
        dist = 1 << (lev-1);
        d = 1 << (M-lev);
        step = 1 << lev;
        for(t=0; t<dist; t++)
        {
            p = t * d;
            for(i=t; i<mLen; i+=step)
            {
                B = Add(rA[i], Mul(rA[i+dist], weight_array64[p]));
                rA[i+dist] = Sub(rA[i], Mul(rA[i+dist], weight_array64[p]));
                rA[i].x = B.x;
                rA[i].y = B.y;
            }
        }
    }

    __global float2* outputPtr = (__global float2*)output.item;
    for(i = 0; i < 64; i++)
    {
        outputPtr[i * 64 + gidx] = rA[i];
    }
#endif
}

__kernel __attribute__((reqd_work_group_size(64, 1, 1))) void fft_256x128(
    vx_array_float input,
    vx_array_float output,
    int nLen, int N, int mLen, int M) //width height
{
    int gidx = get_global_id(0);
    __global float2* A = (__global float2*)input.item;
    //__global float2* tA = (__global float2*)tmpBuf.item;
    __local float2 tmp_array[256 * 16];
    //__local float2* tA = tmp_array;
    int i, j;
    int b = 0;
    int lev, dist, p, t, d, step;
    float2 B;

    for(j = 0; j < 8; j++)
    {
        int offset = (gidx + j * 16) * 256;
        int offset1 = gidx * 256;
        for(i = 0; i < 256; i++)
        {
            b = bitpos_256[i];
            tmp_array[offset1 + i] = A[offset + b];
        }

        __local float2* rA = tmp_array + offset1;

        i = 0;
#if 1 // fft
        for(lev=1; lev<=N; lev++)
        {
            dist = 1 << (lev-1);
            d = 1 << (N-lev);
            step = 1 << lev;
            for(t = 0; t < dist; t++)
            {
                p = t * d;
                for(i = t; i < nLen; i += step)
                {
                    B = Add(rA[i], Mul(rA[i+dist], weight_array256[p]));
                    rA[i+dist] = Sub(rA[i], Mul(rA[i+dist], weight_array256[p]));
                    rA[i].x = B.x;
                    rA[i].y = B.y;
                }
            }
        }
#endif

#if 1
        for(i = 0; i < 256; i++)
        {
            A[offset + i] = rA[i];
        }
#endif
    }
    barrier(CLK_LOCAL_MEM_FENCE);

    // vertical
    for(j = 0; j < 16; j++)
    {
        int offset = j * 16 + gidx;
        int offset1 = gidx * 128;
#if 1
        for(i = 0; i < 128; i++)
        {
            b = bitpos_128[i] << 8;
            tmp_array[offset1 + i] = A[b + offset];
        }
        __local float2* rA = tmp_array + offset1;
#endif

#if 0
        __global float2* outputPtr = (__global float2*)output.item;
        for(i = 0; i < 64; i++)
        {
            outputPtr[i * 64 + gidx] = rA[i];
        }
#endif

#if 1
        i = 0;
        for(lev=1; lev<=M; lev++)
        {
            dist = 1 << (lev-1);
            d = 1 << (M-lev);
            step = 1 << lev;
            for(t=0; t<dist; t++)
            {
                p = t * d;
                for(i=t; i<mLen; i+=step)
                {
                    B = Add(rA[i], Mul(rA[i+dist], weight_array128[p]));
                    rA[i+dist] = Sub(rA[i], Mul(rA[i+dist], weight_array128[p]));
                    rA[i].x = B.x;
                    rA[i].y = B.y;
                }
            }
        }

        __global float2* outputPtr = (__global float2*)output.item;
        for(i = 0; i < 128; i++)
        {
            outputPtr[i * 256 + offset] = rA[i];
        }
#endif
    }
}

__kernel __attribute__((reqd_work_group_size(64, 1, 1))) void ifft_256x128(
    vx_array_float input,
    vx_array_float output,
    int nLen, int N, int mLen, int M) //width height
{
    int gidx = get_global_id(0);
    __global float2* A = (__global float2*)input.item;
    //__global float2* tA = (__global float2*)tmpBuf.item;
    __local float2 tmp_array[256 * 16];
    //__local float2* tA = tmp_array;
    int i, j;
    int b = 0;
    int lev, dist, p, t, d, step;
    float2 B;

    for(j = 0; j < 8; j++)
    {
        int offset = (gidx + j * 16) * 256;
        int offset1 = gidx * 256;
        for(i = 0; i < 256; i++)
        {
            b = bitpos_256[i];
            tmp_array[offset1 + i] = A[offset + b];
            tmp_array[offset1 + i].y = -tmp_array[offset1 + i].y;
        }

        __local float2* rA = tmp_array + offset1;

        i = 0;
#if 1 // fft
        for(lev=1; lev<=N; lev++)
        {
            dist = 1 << (lev-1);
            d = 1 << (N-lev);
            step = 1 << lev;
            for(t = 0; t < dist; t++)
            {
                p = t * d;
                for(i = t; i < nLen; i += step)
                {
                    B = Add(rA[i], Mul(rA[i+dist], weight_array256[p]));
                    rA[i+dist] = Sub(rA[i], Mul(rA[i+dist], weight_array256[p]));
                    rA[i].x = B.x;
                    rA[i].y = B.y;
                }
            }
        }
#endif

#if 1
        for(i = 0; i < 256; i++)
        {
            A[offset + i] = rA[i] / nLen;
        }
#endif
    }
    barrier(CLK_LOCAL_MEM_FENCE);

    // vertical
    for(j = 0; j < 16; j++)
    {
        int offset = j * 16 + gidx;
        int offset1 = gidx * 128;
#if 1
        for(i = 0; i < 128; i++)
        {
            b = bitpos_128[i] << 8;
            tmp_array[offset1 + i] = A[b + offset];
        }
        __local float2* rA = tmp_array + offset1;
#endif

#if 0
        __global float2* outputPtr = (__global float2*)output.item;
        for(i = 0; i < 64; i++)
        {
            outputPtr[i * 64 + gidx] = rA[i];
        }
#endif

#if 1
        i = 0;
        for(lev=1; lev<=M; lev++)
        {
            dist = 1 << (lev-1);
            d = 1 << (M-lev);
            step = 1 << lev;
            for(t=0; t<dist; t++)
            {
                p = t * d;
                for(i=t; i<mLen; i+=step)
                {
                    B = Add(rA[i], Mul(rA[i+dist], weight_array128[p]));
                    rA[i+dist] = Sub(rA[i], Mul(rA[i+dist], weight_array128[p]));
                    rA[i].x = B.x;
                    rA[i].y = B.y;
                }
            }
        }

        __global float2* outputPtr = (__global float2*)output.item;
        for(i = 0; i < 128; i++)
        {
            outputPtr[i * 256 + offset] = rA[i] / mLen;
        }
#endif
    }
}